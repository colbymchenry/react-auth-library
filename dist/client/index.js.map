{"version":3,"sources":["../../src/env/firebase-env.ts","../../src/client/firebase-client.ts","../../src/client/auth-store.ts","../../src/client/auth-provider.tsx"],"names":["firebaseSignOut"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Firebase environment parsing utilities.\n *\n * We keep this logic centralized to avoid leaking env parsing concerns throughout the codebase\n * (SRP) and to provide a single place for validation / error messaging.\n */\nexport interface FirebaseClientConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  appId?: string;\n  measurementId?: string;\n}\n\n/**\n * NOTE: This is the shape we expect from a Firebase Admin service account JSON.\n * We intentionally keep it permissive because Google occasionally adds fields.\n */\nexport interface FirebaseAdminServiceAccount {\n  project_id: string;\n  client_email: string;\n  private_key: string;\n  [key: string]: unknown;\n}\n\nclass FirebaseEnvError extends Error {\n  public readonly name = 'FirebaseEnvError';\n}\n\nfunction parseJsonEnv<T>(envKey: string): T {\n  const raw = process.env[envKey];\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      `Missing environment variable \"${envKey}\". See env.example for the expected shape.`,\n    );\n  }\n\n  try {\n    return JSON.parse(raw) as T;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"${envKey}\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n}\n\nexport function getFirebaseClientConfig(): FirebaseClientConfig {\n  /**\n   * IMPORTANT (Next.js / Turbopack):\n   * Client-side env vars are statically inlined only when accessed with dot-notation\n   * (e.g. `process.env.NEXT_PUBLIC_FOO`). Bracket access (`process.env[key]`) is dynamic and\n   * will evaluate to `undefined` in the browser bundle.\n   *\n   * Therefore we intentionally read `NEXT_PUBLIC_FIREBASE` with dot-notation here.\n   */\n  const raw = process.env.NEXT_PUBLIC_FIREBASE;\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      'Missing environment variable \"NEXT_PUBLIC_FIREBASE\". See env.example for the expected shape.',\n    );\n  }\n\n  let config: FirebaseClientConfig;\n\n  try {\n    config = JSON.parse(raw) as FirebaseClientConfig;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"NEXT_PUBLIC_FIREBASE\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n\n  // Defensive validation: fail fast in development to avoid confusing runtime errors.\n  if (!config.apiKey || !config.authDomain || !config.projectId) {\n    throw new FirebaseEnvError(\n      'NEXT_PUBLIC_FIREBASE is missing required keys. Required: apiKey, authDomain, projectId.',\n    );\n  }\n\n  return config;\n}\n\nexport function getFirebaseAdminServiceAccount(): FirebaseAdminServiceAccount {\n  const serviceAccount = parseJsonEnv<FirebaseAdminServiceAccount>('ADMIN_FIREBASE');\n\n  if (!serviceAccount.project_id || !serviceAccount.client_email || !serviceAccount.private_key) {\n    throw new FirebaseEnvError(\n      'ADMIN_FIREBASE is missing required keys. Required: project_id, client_email, private_key.',\n    );\n  }\n\n  return serviceAccount;\n}\n\n","/**\n * Firebase Client SDK initialization (browser/client components only).\n *\n * This module is intentionally client-safe (no admin SDK, no secrets).\n */\nimport { initializeApp, getApp, getApps } from 'firebase/app';\nimport { GoogleAuthProvider, getAuth } from 'firebase/auth';\nimport { getFirebaseClientConfig } from '../env/firebase-env';\n\nconst firebaseApp = getApps().length ? getApp() : initializeApp(getFirebaseClientConfig());\n\nexport const firebaseAuth = getAuth(firebaseApp);\nexport const googleAuthProvider = new GoogleAuthProvider();\n\n","/**\n * Client-side auth state (Zustand).\n *\n * The server (session cookie) remains the source-of-truth for authorization checks.\n * This store exists to drive UI and initiate login/logout flows.\n */\nimport type { User } from 'firebase/auth';\nimport { create } from 'zustand';\nimport {\n  isSignInWithEmailLink,\n  onAuthStateChanged,\n  sendSignInLinkToEmail,\n  signInWithEmailLink,\n  signInWithPopup,\n  signOut as firebaseSignOut,\n} from 'firebase/auth';\nimport { firebaseAuth, googleAuthProvider } from './firebase-client';\n\nconst EMAIL_FOR_SIGN_IN_STORAGE_KEY = 'firebase.emailForSignIn';\n\ntype AuthStatus = 'idle' | 'initializing' | 'authenticated' | 'unauthenticated';\n\ninterface AuthState {\n  status: AuthStatus;\n  user: User | null;\n  error: string | null;\n\n  /** Starts the Firebase client listener; should be called once from a top-level client provider. */\n  startListener: () => () => void;\n\n  /** Starts a Google popup sign-in, then establishes a server session cookie. */\n  signInWithGoogle: () => Promise<void>;\n\n  /** Sends a passwordless email link, then waits for the user to return via that link. */\n  sendPasswordlessEmailLink: (email: string) => Promise<void>;\n\n  /** Completes the passwordless flow if `url` is a valid sign-in link. */\n  completePasswordlessEmailLink: (url: string, email?: string) => Promise<void>;\n\n  /** Clears both the server session cookie and the Firebase client session. */\n  signOut: () => Promise<void>;\n}\n\nasync function establishServerSessionCookie(): Promise<void> {\n  const currentUser = firebaseAuth.currentUser;\n  if (!currentUser) return;\n\n  const idToken = await currentUser.getIdToken(true);\n\n  const response = await fetch('/api/auth/session', {\n    method: 'POST',\n    headers: { 'content-type': 'application/json' },\n    body: JSON.stringify({ idToken }),\n  });\n\n  if (!response.ok) {\n    throw new Error('Failed to establish server session cookie.');\n  }\n}\n\nexport const useAuthStore = create<AuthState>((set) => ({\n  status: 'idle',\n  user: null,\n  error: null,\n\n  startListener: () => {\n    set({ status: 'initializing', error: null });\n\n    const unsubscribe = onAuthStateChanged(\n      firebaseAuth,\n      (user) => {\n        set({\n          user,\n          status: user ? 'authenticated' : 'unauthenticated',\n          error: null,\n        });\n      },\n      (error) => {\n        set({\n          user: null,\n          status: 'unauthenticated',\n          error: error?.message ?? 'Failed to initialize auth.',\n        });\n      },\n    );\n\n    return unsubscribe;\n  },\n\n  signInWithGoogle: async () => {\n    set({ error: null });\n    await signInWithPopup(firebaseAuth, googleAuthProvider);\n    await establishServerSessionCookie();\n  },\n\n  sendPasswordlessEmailLink: async (email: string) => {\n    set({ error: null });\n\n    if (!email) {\n      set({ error: 'Please enter your email.' });\n      return;\n    }\n\n    if (typeof window === 'undefined') return;\n\n    const actionCodeSettings = {\n      url: `${window.location.origin}/login`,\n      handleCodeInApp: true,\n    };\n\n    await sendSignInLinkToEmail(firebaseAuth, email, actionCodeSettings);\n    window.localStorage.setItem(EMAIL_FOR_SIGN_IN_STORAGE_KEY, email);\n  },\n\n  completePasswordlessEmailLink: async (url: string, email?: string) => {\n    set({ error: null });\n\n    if (typeof window === 'undefined') return;\n    if (!isSignInWithEmailLink(firebaseAuth, url)) return;\n\n    const storedEmail = window.localStorage.getItem(EMAIL_FOR_SIGN_IN_STORAGE_KEY) ?? undefined;\n    const resolvedEmail = email ?? storedEmail;\n\n    if (!resolvedEmail) {\n      set({ error: 'Please enter your email to complete sign-in.' });\n      return;\n    }\n\n    await signInWithEmailLink(firebaseAuth, resolvedEmail, url);\n    window.localStorage.removeItem(EMAIL_FOR_SIGN_IN_STORAGE_KEY);\n    await establishServerSessionCookie();\n  },\n\n  signOut: async () => {\n    set({ error: null });\n\n    // Best-effort server logout first to ensure server-side guards update immediately.\n    try {\n      await fetch('/api/auth/logout', { method: 'POST' });\n    } catch {\n      // noop\n    }\n\n    await firebaseSignOut(firebaseAuth);\n\n    // Ensure UI updates immediately; the auth listener will also confirm this state.\n    set({ user: null, status: 'unauthenticated' });\n  },\n}));\n\n","/**\n * Client provider that initializes Firebase auth listener.\n *\n * Wrap your app in this provider to enable client-side auth state.\n */\n'use client';\n\nimport type { PropsWithChildren } from 'react';\nimport { useEffect } from 'react';\nimport { useAuthStore } from './auth-store';\n\n/**\n * Initializes client-side auth state once for the app.\n *\n * The server enforces authorization via session cookies. This provider only exists to power\n * client UX (showing user state, triggering login/logout flows, etc).\n */\nexport function AuthProvider({ children }: PropsWithChildren) {\n  const startListener = useAuthStore((state) => state.startListener);\n\n  useEffect(() => {\n    const unsubscribe = startListener();\n    return () => unsubscribe();\n  }, [startListener]);\n\n  return children;\n}\n\n"]}