{"version":3,"sources":["../../../src/env/firebase-env.ts","../../../src/server/firebase-admin.ts","../../../src/server/firebase-session.ts","../../../src/next/app-router/auth-guards.ts","../../../src/next/app-router/api-guard.ts","../../../src/next/app-router/route-handlers.ts"],"names":["cookies","NextResponse"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Firebase environment parsing utilities.\n *\n * We keep this logic centralized to avoid leaking env parsing concerns throughout the codebase\n * (SRP) and to provide a single place for validation / error messaging.\n */\nexport interface FirebaseClientConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  appId?: string;\n  measurementId?: string;\n}\n\n/**\n * NOTE: This is the shape we expect from a Firebase Admin service account JSON.\n * We intentionally keep it permissive because Google occasionally adds fields.\n */\nexport interface FirebaseAdminServiceAccount {\n  project_id: string;\n  client_email: string;\n  private_key: string;\n  [key: string]: unknown;\n}\n\nclass FirebaseEnvError extends Error {\n  public readonly name = 'FirebaseEnvError';\n}\n\nfunction parseJsonEnv<T>(envKey: string): T {\n  const raw = process.env[envKey];\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      `Missing environment variable \"${envKey}\". See env.example for the expected shape.`,\n    );\n  }\n\n  try {\n    return JSON.parse(raw) as T;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"${envKey}\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n}\n\nexport function getFirebaseClientConfig(): FirebaseClientConfig {\n  /**\n   * IMPORTANT (Next.js / Turbopack):\n   * Client-side env vars are statically inlined only when accessed with dot-notation\n   * (e.g. `process.env.NEXT_PUBLIC_FOO`). Bracket access (`process.env[key]`) is dynamic and\n   * will evaluate to `undefined` in the browser bundle.\n   *\n   * Therefore we intentionally read `NEXT_PUBLIC_FIREBASE` with dot-notation here.\n   */\n  const raw = process.env.NEXT_PUBLIC_FIREBASE;\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      'Missing environment variable \"NEXT_PUBLIC_FIREBASE\". See env.example for the expected shape.',\n    );\n  }\n\n  let config: FirebaseClientConfig;\n\n  try {\n    config = JSON.parse(raw) as FirebaseClientConfig;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"NEXT_PUBLIC_FIREBASE\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n\n  // Defensive validation: fail fast in development to avoid confusing runtime errors.\n  if (!config.apiKey || !config.authDomain || !config.projectId) {\n    throw new FirebaseEnvError(\n      'NEXT_PUBLIC_FIREBASE is missing required keys. Required: apiKey, authDomain, projectId.',\n    );\n  }\n\n  return config;\n}\n\nexport function getFirebaseAdminServiceAccount(): FirebaseAdminServiceAccount {\n  const serviceAccount = parseJsonEnv<FirebaseAdminServiceAccount>('ADMIN_FIREBASE');\n\n  if (!serviceAccount.project_id || !serviceAccount.client_email || !serviceAccount.private_key) {\n    throw new FirebaseEnvError(\n      'ADMIN_FIREBASE is missing required keys. Required: project_id, client_email, private_key.',\n    );\n  }\n\n  return serviceAccount;\n}\n\n","/**\n * Firebase Admin SDK initialization (server-only).\n *\n * This module must only be imported from server code (route handlers / server components).\n */\nimport admin from 'firebase-admin';\nimport { getFirebaseAdminServiceAccount } from '../env/firebase-env';\n\nfunction initializeAdminApp(): admin.app.App {\n  if (admin.apps.length) return admin.app();\n\n  const serviceAccount = getFirebaseAdminServiceAccount();\n\n  return admin.initializeApp({\n    credential: admin.credential.cert(serviceAccount as admin.ServiceAccount),\n  });\n}\n\nexport const firebaseAdminApp = initializeAdminApp();\nexport const firebaseAdminAuth = firebaseAdminApp.auth();\n\n","/**\n * Firebase session cookie helpers (server-only).\n *\n * We use Firebase Admin to create and verify session cookies. This enables server-side auth checks\n * (redirects, API protection) without relying on client state.\n */\nimport type { DecodedIdToken } from 'firebase-admin/auth';\nimport type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';\nimport { firebaseAdminAuth } from './firebase-admin';\n\nexport const FIREBASE_SESSION_COOKIE_NAME = '__session';\n\n// 5 days is a common default; adjust as needed.\nconst SESSION_EXPIRES_IN_MS = 1000 * 60 * 60 * 24 * 5;\n\nexport interface VerifiedFirebaseUser {\n  uid: string;\n  email?: string;\n  name?: string;\n  picture?: string;\n  claims: DecodedIdToken;\n}\n\nexport function getSessionCookieOptions() {\n  const isProduction = process.env.NODE_ENV === 'production';\n\n  return {\n    httpOnly: true,\n    secure: isProduction,\n    sameSite: 'lax' as const,\n    path: '/',\n    maxAge: Math.floor(SESSION_EXPIRES_IN_MS / 1000),\n  };\n}\n\nexport async function createFirebaseSessionCookie(idToken: string): Promise<string> {\n  return await firebaseAdminAuth.createSessionCookie(idToken, {\n    expiresIn: SESSION_EXPIRES_IN_MS,\n  });\n}\n\nexport async function verifyFirebaseSessionCookie(sessionCookie: string): Promise<DecodedIdToken> {\n  // checkRevoked=true ensures a revoked session is treated as invalid.\n  return await firebaseAdminAuth.verifySessionCookie(sessionCookie, true);\n}\n\nexport async function getVerifiedFirebaseUserFromCookies(\n  cookies: ReadonlyRequestCookies,\n): Promise<VerifiedFirebaseUser | null> {\n  const sessionCookie = cookies.get(FIREBASE_SESSION_COOKIE_NAME)?.value;\n  if (!sessionCookie) return null;\n\n  try {\n    const claims = await verifyFirebaseSessionCookie(sessionCookie);\n\n    return {\n      uid: claims.uid,\n      email: claims.email,\n      name: claims.name,\n      picture: claims.picture,\n      claims,\n    };\n  } catch {\n    return null;\n  }\n}\n\nexport async function revokeFirebaseUserSessions(uid: string): Promise<void> {\n  await firebaseAdminAuth.revokeRefreshTokens(uid);\n}\n\n","/**\n * Server-only auth guards for Next.js App Router.\n *\n * These helpers ensure redirects happen on the server (SSR) using the session cookie verified\n * by Firebase Admin. Middleware also enforces this at the proxy/edge layer, but we still guard\n * at the route layer to keep a strong defense-in-depth posture (and to make routes self-contained).\n */\nimport { cookies } from 'next/headers';\nimport { notFound, redirect } from 'next/navigation';\nimport { getVerifiedFirebaseUserFromCookies } from '../../server/firebase-session';\n\nexport async function getAuthenticatedUser() {\n  const cookieStore = await cookies();\n  return await getVerifiedFirebaseUserFromCookies(cookieStore);\n}\n\n/**\n * Admin detection via Firebase custom claims.\n *\n * Expected options:\n * - `admin: true`\n * - `role: 'admin'`\n *\n * Keep this logic centralized so you can evolve your authorization model without touching routes.\n */\nexport function isAdminUser(user: NonNullable<Awaited<ReturnType<typeof getAuthenticatedUser>>>) {\n  const claims = user.claims ?? {};\n\n  // Common patterns for custom claims.\n  const adminClaim = (claims as Record<string, unknown>)['admin'];\n  const roleClaim = (claims as Record<string, unknown>)['role'];\n\n  return adminClaim === true || roleClaim === 'admin';\n}\n\nexport async function requireAuthenticatedUserOrRedirect(loginPath: string = '/login') {\n  const user = await getAuthenticatedUser();\n\n  if (!user) {\n    redirect(loginPath);\n  }\n\n  return user;\n}\n\nexport async function requireAdminUserOrNotFound(loginPath: string = '/login') {\n  const user = await requireAuthenticatedUserOrRedirect(loginPath);\n\n  if (!isAdminUser(user)) {\n    notFound();\n  }\n\n  return user;\n}\n\nexport async function redirectAuthenticatedUserToDashboard(dashboardPath: string = '/dashboard') {\n  const user = await getAuthenticatedUser();\n\n  if (user) {\n    redirect(dashboardPath);\n  }\n}\n\n","/**\n * API-route auth guard (server-only).\n *\n * Why not reuse the redirect guards?\n * - UI routes should redirect.\n * - API routes should return 401 JSON (no redirects), keeping clients predictable.\n */\nimport { NextResponse } from 'next/server';\nimport { getAuthenticatedUser } from './auth-guards';\n\nexport async function requireAuthenticatedUserOr401() {\n  const user = await getAuthenticatedUser();\n\n  if (!user) {\n    return {\n      user: null,\n      response: NextResponse.json({ error: 'Unauthorized' }, { status: 401 }),\n    } as const;\n  }\n\n  return { user, response: null } as const;\n}\n\n","/**\n * Route handler factories for Firebase Auth API endpoints.\n *\n * These factories create Next.js route handlers for session management.\n * Consumers can use them to quickly set up auth API routes.\n */\nimport { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport {\n  createFirebaseSessionCookie,\n  verifyFirebaseSessionCookie,\n  revokeFirebaseUserSessions,\n  getVerifiedFirebaseUserFromCookies,\n  getSessionCookieOptions,\n  FIREBASE_SESSION_COOKIE_NAME,\n} from '../../server/firebase-session';\n\n/**\n * Creates a POST handler for establishing a session cookie from a Firebase ID token.\n *\n * @example\n * ```typescript\n * // app/api/auth/session/route.ts\n * import { createSessionRouteHandler } from '@volcanica/firebase-auth-nextjs/next/app-router';\n *\n * export const runtime = 'nodejs';\n * export const POST = createSessionRouteHandler();\n * ```\n */\nexport function createSessionRouteHandler() {\n  return async function POST(request: Request) {\n    let body: { idToken?: string } | null = null;\n\n    try {\n      body = (await request.json()) as { idToken?: string };\n    } catch {\n      // noop\n    }\n\n    const idToken = body?.idToken;\n\n    if (!idToken) {\n      return NextResponse.json({ error: 'Missing \"idToken\".' }, { status: 400 });\n    }\n\n    try {\n      const sessionCookie = await createFirebaseSessionCookie(idToken);\n\n      const response = NextResponse.json({ ok: true });\n      response.cookies.set(\n        FIREBASE_SESSION_COOKIE_NAME,\n        sessionCookie,\n        getSessionCookieOptions()\n      );\n\n      return response;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Failed to create session';\n      return NextResponse.json({ error: message }, { status: 401 });\n    }\n  };\n}\n\n/**\n * Creates a GET handler for verifying the current session and returning user info.\n *\n * @example\n * ```typescript\n * // app/api/auth/verify/route.ts\n * import { createVerifyRouteHandler } from '@volcanica/firebase-auth-nextjs/next/app-router';\n *\n * export const runtime = 'nodejs';\n * export const GET = createVerifyRouteHandler();\n * ```\n */\nexport function createVerifyRouteHandler() {\n  return async function GET() {\n    const cookieStore = await cookies();\n    const user = await getVerifiedFirebaseUserFromCookies(cookieStore);\n\n    if (!user) {\n      return NextResponse.json({ authenticated: false }, { status: 401 });\n    }\n\n    return NextResponse.json({\n      authenticated: true,\n      user: {\n        uid: user.uid,\n        email: user.email ?? null,\n        name: user.name ?? null,\n        picture: user.picture ?? null,\n      },\n    });\n  };\n}\n\n/**\n * Creates POST and GET handlers for logout.\n *\n * POST: Revokes Firebase session and clears cookie.\n * GET: Returns 405 Method Not Allowed (prevents accidental logout via link clicks).\n *\n * @example\n * ```typescript\n * // app/api/auth/logout/route.ts\n * import { createLogoutRouteHandlers } from '@volcanica/firebase-auth-nextjs/next/app-router';\n *\n * export const runtime = 'nodejs';\n * export const { POST, GET } = createLogoutRouteHandlers();\n * ```\n */\nexport function createLogoutRouteHandlers() {\n  async function POST() {\n    const cookieStore = await cookies();\n    const sessionCookie = cookieStore.get(FIREBASE_SESSION_COOKIE_NAME)?.value;\n\n    // Best-effort revocation (doesn't block logout if cookie is already invalid).\n    if (sessionCookie) {\n      try {\n        const claims = await verifyFirebaseSessionCookie(sessionCookie);\n        await revokeFirebaseUserSessions(claims.uid);\n      } catch {\n        // noop\n      }\n    }\n\n    const response = NextResponse.json({ ok: true });\n\n    // Clear cookie by setting an immediate expiry with the same cookie attributes.\n    response.cookies.set(FIREBASE_SESSION_COOKIE_NAME, '', {\n      ...getSessionCookieOptions(),\n      maxAge: 0,\n    });\n\n    return response;\n  }\n\n  // Prevent accidental logout via GET (e.g., from link prefetch or browser navigation)\n  async function GET() {\n    return NextResponse.json({ error: 'Method Not Allowed' }, { status: 405 });\n  }\n\n  return { POST, GET };\n}\n\n/**\n * Creates a complete set of auth route handlers (session, verify, logout).\n *\n * This is a convenience export if you want to set up all three endpoints at once\n * (though typically they go in separate route files).\n */\nexport function createAuthRouteHandlers() {\n  return {\n    session: { POST: createSessionRouteHandler() },\n    verify: { GET: createVerifyRouteHandler() },\n    logout: createLogoutRouteHandlers(),\n  };\n}\n\n"]}