{"version":3,"sources":["../../../src/env/firebase-env.ts","../../../src/server/firebase-admin.ts","../../../src/server/firebase-session.ts","../../../src/next/middleware/create-auth-middleware.ts"],"names":["admin","NextResponse"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Firebase environment parsing utilities.\n *\n * We keep this logic centralized to avoid leaking env parsing concerns throughout the codebase\n * (SRP) and to provide a single place for validation / error messaging.\n */\nexport interface FirebaseClientConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  appId?: string;\n  measurementId?: string;\n}\n\n/**\n * NOTE: This is the shape we expect from a Firebase Admin service account JSON.\n * We intentionally keep it permissive because Google occasionally adds fields.\n */\nexport interface FirebaseAdminServiceAccount {\n  project_id: string;\n  client_email: string;\n  private_key: string;\n  [key: string]: unknown;\n}\n\nclass FirebaseEnvError extends Error {\n  public readonly name = 'FirebaseEnvError';\n}\n\nfunction parseJsonEnv<T>(envKey: string): T {\n  const raw = process.env[envKey];\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      `Missing environment variable \"${envKey}\". See env.example for the expected shape.`,\n    );\n  }\n\n  try {\n    return JSON.parse(raw) as T;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"${envKey}\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n}\n\nexport function getFirebaseClientConfig(): FirebaseClientConfig {\n  /**\n   * IMPORTANT (Next.js / Turbopack):\n   * Client-side env vars are statically inlined only when accessed with dot-notation\n   * (e.g. `process.env.NEXT_PUBLIC_FOO`). Bracket access (`process.env[key]`) is dynamic and\n   * will evaluate to `undefined` in the browser bundle.\n   *\n   * Therefore we intentionally read `NEXT_PUBLIC_FIREBASE` with dot-notation here.\n   */\n  const raw = process.env.NEXT_PUBLIC_FIREBASE;\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      'Missing environment variable \"NEXT_PUBLIC_FIREBASE\". See env.example for the expected shape.',\n    );\n  }\n\n  let config: FirebaseClientConfig;\n\n  try {\n    config = JSON.parse(raw) as FirebaseClientConfig;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"NEXT_PUBLIC_FIREBASE\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n\n  // Defensive validation: fail fast in development to avoid confusing runtime errors.\n  if (!config.apiKey || !config.authDomain || !config.projectId) {\n    throw new FirebaseEnvError(\n      'NEXT_PUBLIC_FIREBASE is missing required keys. Required: apiKey, authDomain, projectId.',\n    );\n  }\n\n  return config;\n}\n\nexport function getFirebaseAdminServiceAccount(): FirebaseAdminServiceAccount {\n  const serviceAccount = parseJsonEnv<FirebaseAdminServiceAccount>('ADMIN_FIREBASE');\n\n  if (!serviceAccount.project_id || !serviceAccount.client_email || !serviceAccount.private_key) {\n    throw new FirebaseEnvError(\n      'ADMIN_FIREBASE is missing required keys. Required: project_id, client_email, private_key.',\n    );\n  }\n\n  return serviceAccount;\n}\n\n","/**\n * Firebase Admin SDK initialization (server-only).\n *\n * This module must only be imported from server code (route handlers / server components).\n */\nimport admin from 'firebase-admin';\nimport { getFirebaseAdminServiceAccount } from '../env/firebase-env';\n\nfunction initializeAdminApp(): admin.app.App {\n  if (admin.apps.length) return admin.app();\n\n  const serviceAccount = getFirebaseAdminServiceAccount();\n\n  return admin.initializeApp({\n    credential: admin.credential.cert(serviceAccount as admin.ServiceAccount),\n  });\n}\n\nexport const firebaseAdminApp = initializeAdminApp();\nexport const firebaseAdminAuth = firebaseAdminApp.auth();\n\n","/**\n * Firebase session cookie helpers (server-only).\n *\n * We use Firebase Admin to create and verify session cookies. This enables server-side auth checks\n * (redirects, API protection) without relying on client state.\n */\nimport type { DecodedIdToken } from 'firebase-admin/auth';\nimport type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';\nimport { firebaseAdminAuth } from './firebase-admin';\n\nexport const FIREBASE_SESSION_COOKIE_NAME = '__session';\n\n// 5 days is a common default; adjust as needed.\nconst SESSION_EXPIRES_IN_MS = 1000 * 60 * 60 * 24 * 5;\n\nexport interface VerifiedFirebaseUser {\n  uid: string;\n  email?: string;\n  name?: string;\n  picture?: string;\n  claims: DecodedIdToken;\n}\n\nexport function getSessionCookieOptions() {\n  const isProduction = process.env.NODE_ENV === 'production';\n\n  return {\n    httpOnly: true,\n    secure: isProduction,\n    sameSite: 'lax' as const,\n    path: '/',\n    maxAge: Math.floor(SESSION_EXPIRES_IN_MS / 1000),\n  };\n}\n\nexport async function createFirebaseSessionCookie(idToken: string): Promise<string> {\n  return await firebaseAdminAuth.createSessionCookie(idToken, {\n    expiresIn: SESSION_EXPIRES_IN_MS,\n  });\n}\n\nexport async function verifyFirebaseSessionCookie(sessionCookie: string): Promise<DecodedIdToken> {\n  // checkRevoked=true ensures a revoked session is treated as invalid.\n  return await firebaseAdminAuth.verifySessionCookie(sessionCookie, true);\n}\n\nexport async function getVerifiedFirebaseUserFromCookies(\n  cookies: ReadonlyRequestCookies,\n): Promise<VerifiedFirebaseUser | null> {\n  const sessionCookie = cookies.get(FIREBASE_SESSION_COOKIE_NAME)?.value;\n  if (!sessionCookie) return null;\n\n  try {\n    const claims = await verifyFirebaseSessionCookie(sessionCookie);\n\n    return {\n      uid: claims.uid,\n      email: claims.email,\n      name: claims.name,\n      picture: claims.picture,\n      claims,\n    };\n  } catch {\n    return null;\n  }\n}\n\nexport async function revokeFirebaseUserSessions(uid: string): Promise<void> {\n  await firebaseAdminAuth.revokeRefreshTokens(uid);\n}\n\n","/**\n * Next.js middleware factory for Firebase session-based auth.\n *\n * This middleware performs a **cookie presence check only** (edge-safe).\n * Full cryptographic verification happens in Node runtime (route handlers, server components).\n *\n * Why presence-only?\n * - Edge middleware can't import firebase-admin (requires Node runtime).\n * - Presence check is fast and prevents most unauthorized access attempts.\n * - Server guards provide the actual security boundary with full JWT verification.\n */\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { FIREBASE_SESSION_COOKIE_NAME } from '../../server/firebase-session';\n\nexport interface AuthMiddlewareConfig {\n  /**\n   * Path prefixes that require authentication.\n   * Default: ['/dashboard']\n   *\n   * @example ['/dashboard', '/admin', '/api/protected']\n   */\n  protectedPrefixes?: string[];\n\n  /**\n   * Path to redirect to when session cookie is missing.\n   * Default: '/login'\n   */\n  loginPath?: string;\n\n  /**\n   * Optional: Path to redirect to when session cookie is present on public pages.\n   * Useful for redirecting away from /login if already authenticated.\n   * Default: undefined (no redirect)\n   *\n   * @example '/dashboard'\n   */\n  authenticatedRedirectPath?: string;\n\n  /**\n   * Optional: Paths that should redirect authenticated users.\n   * Only applies when authenticatedRedirectPath is set.\n   * Default: ['/login']\n   *\n   * @example ['/login', '/signup']\n   */\n  publicOnlyPaths?: string[];\n\n  /**\n   * Optional: Custom cookie name if not using default '__session'.\n   * Default: '__session'\n   */\n  cookieName?: string;\n}\n\n/**\n * Creates a Next.js middleware function that checks for Firebase session cookie presence.\n *\n * @example\n * ```typescript\n * // middleware.ts\n * import { createAuthMiddleware } from '@volcanica/firebase-auth-nextjs/next/middleware';\n *\n * export default createAuthMiddleware({\n *   protectedPrefixes: ['/dashboard', '/api/protected'],\n *   loginPath: '/login',\n *   authenticatedRedirectPath: '/dashboard',\n *   publicOnlyPaths: ['/login', '/signup'],\n * });\n *\n * export const config = {\n *   matcher: [\n *     // Match all paths except static files and API routes you want public\n *     '/((?!_next/static|_next/image|favicon.ico|api/public).*)',\n *   ],\n * };\n * ```\n */\nexport function createAuthMiddleware(config: AuthMiddlewareConfig = {}) {\n  const {\n    protectedPrefixes = ['/dashboard'],\n    loginPath = '/login',\n    authenticatedRedirectPath,\n    publicOnlyPaths = ['/login'],\n    cookieName = FIREBASE_SESSION_COOKIE_NAME,\n  } = config;\n\n  return function authMiddleware(request: NextRequest) {\n    const { pathname } = request.nextUrl;\n    const sessionCookie = request.cookies.get(cookieName);\n    const hasSession = Boolean(sessionCookie?.value);\n\n    // Check if current path requires authentication\n    const isProtectedPath = protectedPrefixes.some((prefix) =>\n      pathname.startsWith(prefix)\n    );\n\n    // Check if current path is public-only (e.g., login page)\n    const isPublicOnlyPath = publicOnlyPaths.some((path) =>\n      pathname.startsWith(path)\n    );\n\n    // Case 1: Protected path without session → redirect to login\n    if (isProtectedPath && !hasSession) {\n      const loginUrl = new URL(loginPath, request.url);\n      // Preserve the attempted URL for post-login redirect\n      loginUrl.searchParams.set('from', pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n\n    // Case 2: Public-only path with session → redirect to authenticated area\n    if (\n      isPublicOnlyPath &&\n      hasSession &&\n      authenticatedRedirectPath\n    ) {\n      const dashboardUrl = new URL(authenticatedRedirectPath, request.url);\n      return NextResponse.redirect(dashboardUrl);\n    }\n\n    // Case 3: Allow request to proceed\n    return NextResponse.next();\n  };\n}\n\n/**\n * Helper to create a recommended matcher config for Next.js middleware.\n *\n * @example\n * ```typescript\n * import { createAuthMiddleware, getRecommendedMatcher } from '@volcanica/firebase-auth-nextjs/next/middleware';\n *\n * export default createAuthMiddleware({ ... });\n * export const config = { matcher: getRecommendedMatcher() };\n * ```\n */\nexport function getRecommendedMatcher(): string[] {\n  return [\n    /**\n     * Match all request paths except for the ones starting with:\n     * - _next/static (static files)\n     * - _next/image (image optimization)\n     * - favicon.ico (favicon file)\n     * - public folder content (if you serve assets from /public)\n     */\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\n  ];\n}\n\n"]}