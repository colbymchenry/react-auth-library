{"version":3,"sources":["../src/env/firebase-env.ts","../src/server/firebase-admin.ts","../src/server/firebase-session.ts"],"names":[],"mappings":";;;;;AA2BA,IAAM,gBAAA,GAAN,cAA+B,KAAA,CAAM;AAAA,EACnB,IAAA,GAAO,kBAAA;AACzB,CAAA;AAEA,SAAS,aAAgB,MAAA,EAAmB;AAC1C,EAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA;AAE9B,EAAA,IAAI,CAAC,GAAA,EAAK;AACR,IAAA,MAAM,IAAI,gBAAA;AAAA,MACR,iCAAiC,MAAM,CAAA,0CAAA;AAAA,KACzC;AAAA,EACF;AAEA,EAAA,IAAI;AACF,IAAA,OAAO,IAAA,CAAK,MAAM,GAAG,CAAA;AAAA,EACvB,SAAS,KAAA,EAAO;AACd,IAAA,MAAM,UAAU,KAAA,YAAiB,KAAA,GAAQ,KAAA,CAAM,OAAA,GAAU,OAAO,KAAK,CAAA;AACrE,IAAA,MAAM,IAAI,gBAAA;AAAA,MACR,CAAA,iBAAA,EAAoB,MAAM,CAAA,+CAAA,EAAkD,OAAO,CAAA;AAAA,KACrF;AAAA,EACF;AACF;AAwCO,SAAS,8BAAA,GAA8D;AAC5E,EAAA,MAAM,cAAA,GAAiB,aAA0C,gBAAgB,CAAA;AAEjF,EAAA,IAAI,CAAC,eAAe,UAAA,IAAc,CAAC,eAAe,YAAA,IAAgB,CAAC,eAAe,WAAA,EAAa;AAC7F,IAAA,MAAM,IAAI,gBAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AAEA,EAAA,OAAO,cAAA;AACT;;;AC1FA,SAAS,kBAAA,GAAoC;AAC3C,EAAA,IAAI,KAAA,CAAM,IAAA,CAAK,MAAA,EAAQ,OAAO,MAAM,GAAA,EAAI;AAExC,EAAA,MAAM,iBAAiB,8BAAA,EAA+B;AAEtD,EAAA,OAAO,MAAM,aAAA,CAAc;AAAA,IACzB,UAAA,EAAY,KAAA,CAAM,UAAA,CAAW,IAAA,CAAK,cAAsC;AAAA,GACzE,CAAA;AACH;AAEO,IAAM,mBAAmB,kBAAA,EAAmB;AAClB,iBAAiB,IAAA;;;ACT3C,IAAM,4BAAA,GAA+B","file":"index.js","sourcesContent":["/**\n * Firebase environment parsing utilities.\n *\n * We keep this logic centralized to avoid leaking env parsing concerns throughout the codebase\n * (SRP) and to provide a single place for validation / error messaging.\n */\nexport interface FirebaseClientConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  appId?: string;\n  measurementId?: string;\n}\n\n/**\n * NOTE: This is the shape we expect from a Firebase Admin service account JSON.\n * We intentionally keep it permissive because Google occasionally adds fields.\n */\nexport interface FirebaseAdminServiceAccount {\n  project_id: string;\n  client_email: string;\n  private_key: string;\n  [key: string]: unknown;\n}\n\nclass FirebaseEnvError extends Error {\n  public readonly name = 'FirebaseEnvError';\n}\n\nfunction parseJsonEnv<T>(envKey: string): T {\n  const raw = process.env[envKey];\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      `Missing environment variable \"${envKey}\". See env.example for the expected shape.`,\n    );\n  }\n\n  try {\n    return JSON.parse(raw) as T;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"${envKey}\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n}\n\nexport function getFirebaseClientConfig(): FirebaseClientConfig {\n  /**\n   * IMPORTANT (Next.js / Turbopack):\n   * Client-side env vars are statically inlined only when accessed with dot-notation\n   * (e.g. `process.env.NEXT_PUBLIC_FOO`). Bracket access (`process.env[key]`) is dynamic and\n   * will evaluate to `undefined` in the browser bundle.\n   *\n   * Therefore we intentionally read `NEXT_PUBLIC_FIREBASE` with dot-notation here.\n   */\n  const raw = process.env.NEXT_PUBLIC_FIREBASE;\n\n  if (!raw) {\n    throw new FirebaseEnvError(\n      'Missing environment variable \"NEXT_PUBLIC_FIREBASE\". See env.example for the expected shape.',\n    );\n  }\n\n  let config: FirebaseClientConfig;\n\n  try {\n    config = JSON.parse(raw) as FirebaseClientConfig;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new FirebaseEnvError(\n      `Invalid JSON in \"NEXT_PUBLIC_FIREBASE\". Make sure it is a JSON string. Parse error: ${message}`,\n    );\n  }\n\n  // Defensive validation: fail fast in development to avoid confusing runtime errors.\n  if (!config.apiKey || !config.authDomain || !config.projectId) {\n    throw new FirebaseEnvError(\n      'NEXT_PUBLIC_FIREBASE is missing required keys. Required: apiKey, authDomain, projectId.',\n    );\n  }\n\n  return config;\n}\n\nexport function getFirebaseAdminServiceAccount(): FirebaseAdminServiceAccount {\n  const serviceAccount = parseJsonEnv<FirebaseAdminServiceAccount>('ADMIN_FIREBASE');\n\n  if (!serviceAccount.project_id || !serviceAccount.client_email || !serviceAccount.private_key) {\n    throw new FirebaseEnvError(\n      'ADMIN_FIREBASE is missing required keys. Required: project_id, client_email, private_key.',\n    );\n  }\n\n  return serviceAccount;\n}\n\n","/**\n * Firebase Admin SDK initialization (server-only).\n *\n * This module must only be imported from server code (route handlers / server components).\n */\nimport admin from 'firebase-admin';\nimport { getFirebaseAdminServiceAccount } from '../env/firebase-env';\n\nfunction initializeAdminApp(): admin.app.App {\n  if (admin.apps.length) return admin.app();\n\n  const serviceAccount = getFirebaseAdminServiceAccount();\n\n  return admin.initializeApp({\n    credential: admin.credential.cert(serviceAccount as admin.ServiceAccount),\n  });\n}\n\nexport const firebaseAdminApp = initializeAdminApp();\nexport const firebaseAdminAuth = firebaseAdminApp.auth();\n\n","/**\n * Firebase session cookie helpers (server-only).\n *\n * We use Firebase Admin to create and verify session cookies. This enables server-side auth checks\n * (redirects, API protection) without relying on client state.\n */\nimport type { DecodedIdToken } from 'firebase-admin/auth';\nimport type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';\nimport { firebaseAdminAuth } from './firebase-admin';\n\nexport const FIREBASE_SESSION_COOKIE_NAME = '__session';\n\n// 5 days is a common default; adjust as needed.\nconst SESSION_EXPIRES_IN_MS = 1000 * 60 * 60 * 24 * 5;\n\nexport interface VerifiedFirebaseUser {\n  uid: string;\n  email?: string;\n  name?: string;\n  picture?: string;\n  claims: DecodedIdToken;\n}\n\nexport function getSessionCookieOptions() {\n  const isProduction = process.env.NODE_ENV === 'production';\n\n  return {\n    httpOnly: true,\n    secure: isProduction,\n    sameSite: 'lax' as const,\n    path: '/',\n    maxAge: Math.floor(SESSION_EXPIRES_IN_MS / 1000),\n  };\n}\n\nexport async function createFirebaseSessionCookie(idToken: string): Promise<string> {\n  return await firebaseAdminAuth.createSessionCookie(idToken, {\n    expiresIn: SESSION_EXPIRES_IN_MS,\n  });\n}\n\nexport async function verifyFirebaseSessionCookie(sessionCookie: string): Promise<DecodedIdToken> {\n  // checkRevoked=true ensures a revoked session is treated as invalid.\n  return await firebaseAdminAuth.verifySessionCookie(sessionCookie, true);\n}\n\nexport async function getVerifiedFirebaseUserFromCookies(\n  cookies: ReadonlyRequestCookies,\n): Promise<VerifiedFirebaseUser | null> {\n  const sessionCookie = cookies.get(FIREBASE_SESSION_COOKIE_NAME)?.value;\n  if (!sessionCookie) return null;\n\n  try {\n    const claims = await verifyFirebaseSessionCookie(sessionCookie);\n\n    return {\n      uid: claims.uid,\n      email: claims.email,\n      name: claims.name,\n      picture: claims.picture,\n      claims,\n    };\n  } catch {\n    return null;\n  }\n}\n\nexport async function revokeFirebaseUserSessions(uid: string): Promise<void> {\n  await firebaseAdminAuth.revokeRefreshTokens(uid);\n}\n\n"]}